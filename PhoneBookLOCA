#!/usr/bin/env python3
"""
PhoneBookLOCA v1.1 - Phone Number Location Lookup Tool
OSINT tool for educational purposes only
"""

import sys
import json
import argparse
import csv
import re
import os
import webbrowser
from typing import Dict, Optional, Tuple, List
from datetime import datetime
from pathlib import Path
from urllib.parse import quote

try:
    import phonenumbers
    from phonenumbers import geocoder, carrier, timezone
except ImportError:
    print("\n[!] Error: 'phonenumbers' module not found")
    print("[*] Install with: pip3 install -r requirements.txt")
    sys.exit(1)

try:
    import requests
except ImportError:
    print("\n[!] Error: 'requests' module not found")
    print("[*] Install with: pip3 install -r requirements.txt")
    sys.exit(1)


class Colors:
    """ANSI color codes for terminal output"""
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    MAGENTA = '\033[95m'
    CYAN = '\033[96m'
    WHITE = '\033[97m'
    BOLD = '\033[1m'
    RESET = '\033[0m'


class APIConfig:
    """Store API keys and configuration"""
    def __init__(self):
        self.config_file = Path.home() / '.phonebookloca_config.json'
        self.config = self.load_config()
    
    def load_config(self) -> Dict:
        """Load configuration from file"""
        if self.config_file.exists():
            try:
                with open(self.config_file, 'r') as f:
                    return json.load(f)
            except:
                return {}
        return {}
    
    def save_config(self):
        """Save configuration to file"""
        try:
            with open(self.config_file, 'w') as f:
                json.dump(self.config, f, indent=2)
        except Exception as e:
            print(f"[!] Error saving config: {e}")
    
    def set_api_key(self, service: str, key: str):
        """Set API key for a service"""
        self.config[service] = key
        self.save_config()
    
    def get_api_key(self, service: str) -> Optional[str]:
        """Get API key for a service"""
        return self.config.get(service)


class PhoneIntel:
    """Main intelligence gathering class"""
    
    def __init__(self):
        self.results_cache = []
        self.api_config = APIConfig()
        
    def print_banner(self):
        """Display the tool banner"""
        print("\n" + "="*50)
        print("  PhoneBookLOCA v1.1 - OSINT Phone Lookup")
        print("  DEV: DEZTHEJACKAL")
        print("  v1.1 Features: 0xb0rn3")
        print("="*50 + "\n")

    def validate_phone_number(self, number: str) -> Tuple[bool, Optional[phonenumbers.PhoneNumber], Optional[str]]:
        """
        Validate and parse phone number
        
        Args:
            number (str): Phone number to validate
            
        Returns:
            tuple: (is_valid, parsed_number, error_message)
        """
        try:
            parsed = phonenumbers.parse(number, None)
            if phonenumbers.is_valid_number(parsed):
                return True, parsed, None
            else:
                return False, None, "Invalid phone number format"
        except phonenumbers.NumberParseException as e:
            return False, None, f"Parse error: {str(e)}"

    def get_number_type(self, parsed: phonenumbers.PhoneNumber) -> str:
        """Determine the type of phone number"""
        number_type = phonenumbers.number_type(parsed)
        type_mapping = {
            phonenumbers.PhoneNumberType.FIXED_LINE: "Fixed Line",
            phonenumbers.PhoneNumberType.MOBILE: "Mobile",
            phonenumbers.PhoneNumberType.FIXED_LINE_OR_MOBILE: "Fixed Line or Mobile",
            phonenumbers.PhoneNumberType.TOLL_FREE: "Toll Free",
            phonenumbers.PhoneNumberType.PREMIUM_RATE: "Premium Rate",
            phonenumbers.PhoneNumberType.SHARED_COST: "Shared Cost",
            phonenumbers.PhoneNumberType.VOIP: "VoIP",
            phonenumbers.PhoneNumberType.PERSONAL_NUMBER: "Personal Number",
            phonenumbers.PhoneNumberType.PAGER: "Pager",
            phonenumbers.PhoneNumberType.UAN: "UAN",
            phonenumbers.PhoneNumberType.VOICEMAIL: "Voicemail",
            phonenumbers.PhoneNumberType.UNKNOWN: "Unknown"
        }
        return type_mapping.get(number_type, "Unknown")

    def format_number_variants(self, parsed: phonenumbers.PhoneNumber) -> Dict[str, str]:
        """Generate different format variants of the number"""
        return {
            "E164": phonenumbers.format_number(parsed, phonenumbers.PhoneNumberFormat.E164),
            "International": phonenumbers.format_number(parsed, phonenumbers.PhoneNumberFormat.INTERNATIONAL),
            "National": phonenumbers.format_number(parsed, phonenumbers.PhoneNumberFormat.NATIONAL),
            "RFC3966": phonenumbers.format_number(parsed, phonenumbers.PhoneNumberFormat.RFC3966)
        }

    def get_regional_info(self, parsed: phonenumbers.PhoneNumber) -> Dict[str, str]:
        """Get regional information"""
        region_code = phonenumbers.region_code_for_number(parsed)
        return {
            "region_code": region_code or "Unknown",
            "country_name": geocoder.country_name_for_number(parsed, "en") or "Unknown"
        }

    def extract_numbers_from_text(self, text: str, default_region: str = "US") -> List[str]:
        """
        Extract phone numbers from free-form text
        
        Args:
            text: Text containing potential phone numbers
            default_region: Default country code for parsing
            
        Returns:
            List of extracted phone numbers
        """
        numbers = []
        for match in phonenumbers.PhoneNumberMatcher(text, default_region):
            numbers.append(phonenumbers.format_number(match.number, phonenumbers.PhoneNumberFormat.E164))
        return list(set(numbers))

    def generate_number_variants(self, parsed: phonenumbers.PhoneNumber) -> List[str]:
        """
        Generate common formatting variants
        
        Args:
            parsed: Parsed phone number object
            
        Returns:
            List of number format variants
        """
        variants = []
        
        e164 = phonenumbers.format_number(parsed, phonenumbers.PhoneNumberFormat.E164)
        national = phonenumbers.format_number(parsed, phonenumbers.PhoneNumberFormat.NATIONAL)
        
        variants.extend([
            e164,
            e164.replace('+', ''),
            national,
            national.replace(' ', ''),
            national.replace('-', ''),
            national.replace('(', '').replace(')', ''),
            f"00{e164[1:]}"
        ])
        
        return list(set(variants))

    def generate_osint_queries(self, number: str) -> Dict[str, List[str]]:
        """Generate Google dorks and search queries"""
        queries = {
            "google_dorks": [
                f'"{number}"',
                f'"{number}" email',
                f'site:facebook.com "{number}"',
                f'site:linkedin.com "{number}"',
                f'site:twitter.com "{number}"',
                f'site:instagram.com "{number}"',
                f'site:*.paste* "{number}"',
                f'site:github.com "{number}"',
                f'intext:"{number}" (email | contact | phone)',
            ],
            "social_media": [
                f'Facebook: site:facebook.com "{number}"',
                f'LinkedIn: site:linkedin.com "{number}"',
                f'Twitter: site:twitter.com "{number}"',
                f'Instagram: site:instagram.com "{number}"',
            ],
            "data_leaks": [
                f'site:pastebin.com "{number}"',
                f'site:ghostbin.com "{number}"',
                f'site:paste.ee "{number}"',
                f'"database leak" "{number}"',
            ]
        }
        return queries

    def generate_lookup_urls(self, number: str) -> Dict[str, str]:
        """Generate direct URLs to online lookup services"""
        clean_number = number.replace('+', '').replace(' ', '').replace('-', '')
        return {
            "TrueCaller": f"https://www.truecaller.com/search/us/{quote(number)}",
            "WhoCalledMe": f"https://whocalledme.com/Phone-Number.aspx/{clean_number}",
            "Sync.me": f"https://sync.me/",
            "Whitepages": f"https://www.whitepages.com/phone/{clean_number}",
            "SpyDialer": f"https://www.spydialer.com/",
            "NumLookup": f"https://www.numlookup.com/",
        }

    def check_disposable(self, parsed: phonenumbers.PhoneNumber) -> Dict[str, any]:
        """Check if number is from known VoIP/disposable provider"""
        number_type = self.get_number_type(parsed)
        e164 = phonenumbers.format_number(parsed, phonenumbers.PhoneNumberFormat.E164)
        
        voip_indicators = {
            "is_voip": number_type == "VoIP",
            "is_toll_free": number_type == "Toll Free",
            "likely_disposable": False
        }
        
        # Check for known VoIP/disposable patterns
        disposable_patterns = [
            ('+1844', 'Toll-Free'),
            ('+1855', 'Toll-Free'),
            ('+1866', 'Toll-Free'),
            ('+1877', 'Toll-Free'),
            ('+1888', 'Toll-Free'),
        ]
        
        for pattern, service in disposable_patterns:
            if e164.startswith(pattern):
                voip_indicators["likely_disposable"] = True
                voip_indicators["service_type"] = service
                break
        
        return voip_indicators

    def check_reputation_free(self, number: str) -> Dict[str, any]:
        """Check number reputation using free methods"""
        print(f"\n[*] Checking reputation (this may take a moment)...")
        
        reputation = {
            "checked": True,
            "spam_likely": False,
            "sources_checked": []
        }
        
        # In a real implementation, you could:
        # - Scrape public spam databases
        # - Check against known scammer lists
        # - Use free APIs without keys
        
        # For now, return structure for future implementation
        reputation["sources_checked"].append("Local database")
        
        return reputation

    def numverify_lookup(self, number: str) -> Optional[Dict]:
        """
        Use NumVerify API (free tier available)
        User needs to provide API key
        """
        api_key = self.api_config.get_api_key('numverify')
        
        if not api_key:
            return None
        
        try:
            clean_number = number.replace('+', '')
            url = f"http://apilayer.net/api/validate?access_key={api_key}&number={clean_number}"
            response = requests.get(url, timeout=5)
            
            if response.status_code == 200:
                data = response.json()
                if data.get('valid'):
                    return {
                        "valid": data.get('valid'),
                        "number": data.get('number'),
                        "local_format": data.get('local_format'),
                        "international_format": data.get('international_format'),
                        "country_prefix": data.get('country_prefix'),
                        "country_code": data.get('country_code'),
                        "country_name": data.get('country_name'),
                        "location": data.get('location'),
                        "carrier": data.get('carrier'),
                        "line_type": data.get('line_type')
                    }
        except Exception as e:
            print(f"[!] NumVerify lookup failed: {e}")
        
        return None

    def twilio_lookup(self, number: str) -> Optional[Dict]:
        """
        Use Twilio Lookup API (paid)
        User needs to provide Account SID and Auth Token
        """
        account_sid = self.api_config.get_api_key('twilio_sid')
        auth_token = self.api_config.get_api_key('twilio_token')
        
        if not account_sid or not auth_token:
            return None
        
        try:
            url = f"https://lookups.twilio.com/v1/PhoneNumbers/{number}"
            response = requests.get(url, auth=(account_sid, auth_token), timeout=5)
            
            if response.status_code == 200:
                data = response.json()
                return {
                    "phone_number": data.get('phone_number'),
                    "country_code": data.get('country_code'),
                    "national_format": data.get('national_format'),
                    "carrier": data.get('carrier', {}).get('name') if 'carrier' in data else None,
                    "type": data.get('carrier', {}).get('type') if 'carrier' in data else None,
                }
        except Exception as e:
            print(f"[!] Twilio lookup failed: {e}")
        
        return None

    def execute_osint_scan(self, number: str) -> Optional[Dict]:
        """
        Execute fast OSINT scan using Go scraper with loading animation
        
        Args:
            number: Phone number to scan
            
        Returns:
            Dictionary with scan results
        """
        go_scraper = Path(__file__).parent / 'scraper'
        
        # Check for Windows executable
        if not go_scraper.exists():
            go_scraper = Path(__file__).parent / 'scraper.exe'
        
        if not go_scraper.exists():
            print(f"[!] Web scanner not available")
            print(f"[*] Install with: ./install.sh\n")
            return None
        
        try:
            import subprocess
            import threading
            import time
            
            # Loading animation
            stop_animation = threading.Event()
            
            def animate():
                """Display loading animation"""
                chars = ["⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"]
                idx = 0
                while not stop_animation.is_set():
                    print(f"\r[{chars[idx % len(chars)]}] Scanning web sources...", end='', flush=True)
                    idx += 1
                    time.sleep(0.1)
                print("\r" + " " * 50 + "\r", end='', flush=True)  # Clear line
            
            # Start animation
            anim_thread = threading.Thread(target=animate, daemon=True)
            anim_thread.start()
            
            # Run scraper
            result = subprocess.run(
                [str(go_scraper), number],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            # Stop animation
            stop_animation.set()
            anim_thread.join(timeout=0.5)
            
            if result.returncode == 0:
                # Parse JSON from stdout
                try:
                    scan_data = json.loads(result.stdout.strip())
                    return scan_data
                except json.JSONDecodeError as e:
                    print(f"[!] Scan failed: Unable to parse results")
                    return None
            else:
                print(f"[!] Scan failed: {result.stderr}")
                return None
                
        except subprocess.TimeoutExpired:
            stop_animation.set()
            print(f"[!] Scan timed out after 30 seconds")
            return None
        except Exception as e:
            print(f"[!] Scan failed: {e}")
            return None

    def display_osint_scan_results(self, scan_data: Dict):
        """Display results from OSINT scan in a clean format"""
        if not scan_data:
            return
        
        summary = scan_data['summary']
        
        # Summary bar
        print(f"\n{'='*50}")
        print(f"  Web Intelligence Results")
        print(f"{'='*50}")
        print(f"  Checked: {summary['total_sources']} sources")
        print(f"  Found: {summary['found_in']} platforms")
        print(f"  Time: ~{sum(r['response_time'] for r in scan_data['results'])/len(scan_data['results']):.1f}s avg")
        print(f"{'='*50}\n")
        
        if summary['platforms_found']:
            print(f"{Colors.GREEN}[✓] Number found on:{Colors.RESET}")
            for platform in summary['platforms_found']:
                # Find the result for this platform
                for result in scan_data['results']:
                    if result['source'] == platform and result.get('snippet'):
                        print(f"    • {Colors.BOLD}{platform}{Colors.RESET}")
                        print(f"      {result['snippet']}")
                        if result.get('url'):
                            print(f"      {Colors.CYAN}→ {result['url']}{Colors.RESET}")
                        break
            print()
        else:
            print(f"{Colors.YELLOW}[!] Number not found on any checked platforms{Colors.RESET}\n")
        
        # Show negative results briefly
        not_found = [r['source'] for r in scan_data['results'] if not r['found']]
        if not_found:
            print(f"{Colors.YELLOW}[✗] Not found on:{Colors.RESET} {', '.join(not_found)}\n")

    def lookup_phone_number(self, number: str, verbose: bool = False, 
                          json_output: bool = False, show_variants: bool = False,
                          osint_mode: bool = False, reputation: bool = False,
                          web_scan: bool = False) -> Optional[Dict]:
        """
        Perform comprehensive phone number lookup
        
        Args:
            number (str): Phone number to lookup
            osint_mode (bool): Generate OSINT queries and URLs
            reputation (bool): Check reputation
        """
        if not json_output:
            print(f"[*] Target: {number}")
            print(f"[*] Initiating trace...\n")
        
        is_valid, parsed, error = self.validate_phone_number(number)
        
        if not is_valid:
            if not json_output:
                print(f"[!] Error: {error}")
                print("[!] Trace failed\n")
            return None
        
        location = geocoder.description_for_number(parsed, "en")
        if not location:
            location = "Unknown"
        
        carrier_name = carrier.name_for_number(parsed, "en")
        if not carrier_name:
            carrier_name = "Unknown"
        
        timezones = timezone.time_zones_for_number(parsed)
        if not timezones:
            timezones = ["Unknown"]
        
        country_code = f"+{parsed.country_code}"
        number_type = self.get_number_type(parsed)
        formats = self.format_number_variants(parsed)
        regional_info = self.get_regional_info(parsed)
        
        results = {
            "timestamp": datetime.now().isoformat(),
            "input": number,
            "valid": True,
            "country_code": country_code,
            "region_code": regional_info["region_code"],
            "country_name": regional_info["country_name"],
            "location": location,
            "carrier": carrier_name,
            "type": number_type,
            "timezones": timezones,
            "formats": formats
        }
        
        # Check disposable/VoIP
        disposable_check = self.check_disposable(parsed)
        results["voip_check"] = disposable_check
        
        # API lookups
        if self.api_config.get_api_key('numverify'):
            numverify_data = self.numverify_lookup(number)
            if numverify_data:
                results["numverify"] = numverify_data
        
        if self.api_config.get_api_key('twilio_sid'):
            twilio_data = self.twilio_lookup(number)
            if twilio_data:
                results["twilio"] = twilio_data
        
        # Reputation check
        if reputation:
            rep_data = self.check_reputation_free(number)
            results["reputation"] = rep_data
        
        # OSINT mode
        if osint_mode:
            results["osint_queries"] = self.generate_osint_queries(number)
            results["lookup_urls"] = self.generate_lookup_urls(number)
            
            # Execute web scan if requested
            if web_scan:
                scan_data = self.execute_osint_scan(number)
                if scan_data:
                    results["web_scan"] = scan_data
        
        if show_variants:
            results["common_variants"] = self.generate_number_variants(parsed)
        
        self.results_cache.append(results)
        
        if json_output:
            return results
        
        # Display results
        print("[+] Results:")
        print(f"    Country Code: {country_code}")
        print(f"    Country: {regional_info['country_name']}")
        print(f"    Region: {regional_info['region_code']}")
        print(f"    Location: {location}")
        print(f"    Carrier: {carrier_name}")
        print(f"    Type: {number_type}")
        print(f"    Timezone(s): {', '.join(timezones)}")
        print(f"    Valid: Yes")
        
        # VoIP/Disposable info
        if disposable_check["is_voip"]:
            print(f"\n[*] VoIP Detection:")
            print(f"    VoIP Number: Yes")
        if disposable_check["likely_disposable"]:
            print(f"    Likely Disposable: Yes")
            if "service_type" in disposable_check:
                print(f"    Service Type: {disposable_check['service_type']}")
        
        # API results
        if "numverify" in results:
            print(f"\n[*] NumVerify API:")
            nv = results["numverify"]
            print(f"    Carrier: {nv.get('carrier', 'N/A')}")
            print(f"    Line Type: {nv.get('line_type', 'N/A')}")
        
        if "twilio" in results:
            print(f"\n[*] Twilio API:")
            tw = results["twilio"]
            print(f"    Carrier: {tw.get('carrier', 'N/A')}")
            print(f"    Type: {tw.get('type', 'N/A')}")
        
        # Reputation
        if reputation and "reputation" in results:
            print(f"\n[*] Reputation Check:")
            rep = results["reputation"]
            print(f"    Spam Likely: {rep['spam_likely']}")
            print(f"    Sources Checked: {', '.join(rep['sources_checked'])}")
        
        if verbose:
            print(f"\n[*] Format Variants:")
            for fmt_name, fmt_value in formats.items():
                print(f"    {fmt_name}: {fmt_value}")
        
        if show_variants:
            print(f"\n[*] Common Format Variants:")
            for variant in self.generate_number_variants(parsed):
                print(f"    • {variant}")
        
        # OSINT queries
        if osint_mode:
            print(f"\n[*] OSINT Queries Generated:")
            queries = results["osint_queries"]
            
            print(f"\n  Google Dorks:")
            for q in queries["google_dorks"][:5]:
                print(f"    • {q}")
            
            print(f"\n  Lookup URLs:")
            for name, url in list(results["lookup_urls"].items())[:5]:
                print(f"    • {name}: {url}")
            
            # Display web scan results if available
            if "web_scan" in results:
                self.display_osint_scan_results(results["web_scan"])
        
        print("\n[+] Trace Complete\n")
        return results

    def batch_lookup(self, filename: str, output_file: Optional[str] = None, 
                    output_format: str = 'json', show_progress: bool = True,
                    osint_mode: bool = False, reputation: bool = False):
        """Process multiple phone numbers from a file"""
        print(f"\n[*] Batch mode: Processing {filename}\n")
        
        try:
            with open(filename, 'r') as f:
                numbers = [line.strip() for line in f if line.strip() and not line.startswith('#')]
            
            results = []
            successful = 0
            failed = 0
            
            for i, number in enumerate(numbers, 1):
                if show_progress:
                    print(f"[{i}/{len(numbers)}] Processing: {number}")
                
                result = self.lookup_phone_number(number, json_output=True, 
                                                 osint_mode=osint_mode, reputation=reputation)
                if result:
                    results.append(result)
                    successful += 1
                    if show_progress:
                        print("✓ Success\n")
                else:
                    failed += 1
                    if show_progress:
                        print("✗ Failed\n")
            
            if output_file and results:
                self.export_results(results, output_file, output_format)
            
            print(f"[+] Batch Complete")
            print(f"    Total: {len(numbers)} | Success: {successful} | Failed: {failed}\n")
            
        except FileNotFoundError:
            print(f"[!] Error: File '{filename}' not found\n")
        except Exception as e:
            print(f"[!] Error: {str(e)}\n")

    def export_results(self, results: List[Dict], output_file: str, format_type: str = 'json'):
        """
        Export results in various formats
        
        Args:
            results: List of result dictionaries
            output_file: Output filename
            format_type: Export format (json, csv, txt)
        """
        try:
            if format_type == 'json':
                with open(output_file, 'w') as f:
                    json.dump(results, f, indent=2)
                print(f"[+] JSON results saved to: {output_file}\n")
                
            elif format_type == 'csv':
                if not results:
                    return
                
                csv_data = []
                for r in results:
                    flat = {
                        'timestamp': r['timestamp'],
                        'input': r['input'],
                        'valid': r['valid'],
                        'country_code': r['country_code'],
                        'country_name': r.get('country_name', 'N/A'),
                        'region_code': r.get('region_code', 'N/A'),
                        'location': r['location'],
                        'carrier': r['carrier'],
                        'type': r['type'],
                        'timezones': ', '.join(r['timezones']),
                        'e164': r['formats']['E164'],
                        'is_voip': r.get('voip_check', {}).get('is_voip', False)
                    }
                    csv_data.append(flat)
                
                with open(output_file, 'w', newline='') as f:
                    writer = csv.DictWriter(f, fieldnames=csv_data[0].keys())
                    writer.writeheader()
                    writer.writerows(csv_data)
                print(f"[+] CSV results saved to: {output_file}\n")
                
            elif format_type == 'txt':
                with open(output_file, 'w') as f:
                    f.write("PhoneBookLOCA v1.1 - OSINT Results\n")
                    f.write("=" * 50 + "\n\n")
                    for r in results:
                        f.write(f"Target: {r['input']}\n")
                        f.write(f"Timestamp: {r['timestamp']}\n")
                        f.write(f"Country: {r.get('country_name', 'N/A')} ({r['country_code']})\n")
                        f.write(f"Location: {r['location']}\n")
                        f.write(f"Carrier: {r['carrier']}\n")
                        f.write(f"Type: {r['type']}\n")
                        f.write(f"Timezones: {', '.join(r['timezones'])}\n")
                        
                        if r.get('voip_check', {}).get('is_voip'):
                            f.write(f"VoIP: Yes\n")
                        
                        f.write("-" * 50 + "\n\n")
                print(f"[+] TXT results saved to: {output_file}\n")
                
        except Exception as e:
            print(f"[!] Export error: {str(e)}\n")

    def scan_text_file(self, filename: str, output_file: Optional[str] = None):
        """Scan a text file and extract all phone numbers"""
        print(f"\n[*] Scanning file for phone numbers: {filename}\n")
        
        try:
            with open(filename, 'r') as f:
                text = f.read()
            
            numbers = self.extract_numbers_from_text(text)
            
            if not numbers:
                print(f"[!] No phone numbers found in file\n")
                return
            
            print(f"[+] Found {len(numbers)} phone number(s):")
            for num in numbers:
                print(f"    • {num}")
            
            if output_file:
                with open(output_file, 'w') as f:
                    for num in numbers:
                        f.write(f"{num}\n")
                print(f"\n[+] Extracted numbers saved to: {output_file}\n")
            else:
                print()
            
        except FileNotFoundError:
            print(f"[!] Error: File '{filename}' not found\n")
        except Exception as e:
            print(f"[!] Error: {str(e)}\n")

    def configure_apis(self):
        """Interactive API configuration"""
        print("\n[*] API Configuration")
        print("Configure your API keys for additional features\n")
        
        print("Available APIs:")
        print("1. NumVerify (Free tier available)")
        print("   Get key at: https://numverify.com/")
        print("2. Twilio Lookup (Paid)")
        print("   Get credentials at: https://www.twilio.com/\n")
        
        choice = input("Configure API? (1/2/skip): ").strip()
        
        if choice == '1':
            key = input("Enter NumVerify API key: ").strip()
            if key:
                self.api_config.set_api_key('numverify', key)
                print("[+] NumVerify API key saved\n")
        
        elif choice == '2':
            sid = input("Enter Twilio Account SID: ").strip()
            token = input("Enter Twilio Auth Token: ").strip()
            if sid and token:
                self.api_config.set_api_key('twilio_sid', sid)
                self.api_config.set_api_key('twilio_token', token)
                print("[+] Twilio credentials saved\n")

    def interactive_mode(self, verbose: bool = False):
        """Run the tool in interactive mode"""
        self.print_banner()
        print("Enter phone numbers to lookup (with country code, e.g., +1234567890)")
        print("Type 'help' for commands\n")
        
        while True:
            try:
                user_input = input("PhoneBook> ").strip()
                
                if user_input.lower() in ['quit', 'exit', 'q']:
                    print("\n[*] Exiting PhoneBookLOCA. Goodbye!\n")
                    break
                
                if user_input.lower() == 'help':
                    print("\nAvailable Commands:")
                    print("  • Enter a phone number (e.g., +14155552671)")
                    print("  • 'osint <number>' - Generate OSINT queries and URLs")
                    print("  • 'reputation <number>' - Check reputation")
                    print("  • 'stats' - Show session statistics")
                    print("  • 'export' - Export session results")
                    print("  • 'clear' - Clear session cache")
                    print("  • 'config' - Configure API keys")
                    print("  • 'help' - Show this message")
                    print("  • 'quit' - Exit the tool\n")
                    continue
                
                if user_input.lower() == 'stats':
                    self.show_statistics()
                    continue
                
                if user_input.lower() == 'config':
                    self.configure_apis()
                    continue
                
                if user_input.lower() == 'export':
                    filename = input("Export filename (default: results.json): ").strip() or "results.json"
                    if self.results_cache:
                        self.export_results(self.results_cache, filename, 'json')
                    else:
                        print("[!] No results to export\n")
                    continue
                
                if user_input.lower() == 'clear':
                    self.results_cache.clear()
                    print("[+] Session cache cleared\n")
                    continue
                
                # Check for osint command
                if user_input.lower().startswith('osint '):
                    number = user_input[6:].strip()
                    print()
                    self.lookup_phone_number(number, verbose=verbose, osint_mode=True, web_scan=True)
                    continue
                
                # Check for reputation command
                if user_input.lower().startswith('reputation '):
                    number = user_input[11:].strip()
                    print()
                    self.lookup_phone_number(number, verbose=verbose, reputation=True)
                    continue
                
                if not user_input:
                    print("[!] Please enter a phone number or command\n")
                    continue
                
                print()
                self.lookup_phone_number(user_input, verbose=verbose)
                
            except KeyboardInterrupt:
                print("\n\n[*] Interrupted. Exiting...\n")
                break
            except Exception as e:
                print(f"\n[!] Unexpected error: {str(e)}\n")

    def show_statistics(self):
        """Display session statistics"""
        if not self.results_cache:
            print("\n[!] No lookups performed this session\n")
            return
        
        print("\n[*] Session Statistics:")
        print(f"    Total Lookups: {len(self.results_cache)}")
        
        countries = {}
        carriers = {}
        types = {}
        voip_count = 0
        
        for result in self.results_cache:
            country = result.get('country_name', 'Unknown')
            countries[country] = countries.get(country, 0) + 1
            
            carrier = result.get('carrier', 'Unknown')
            carriers[carrier] = carriers.get(carrier, 0) + 1
            
            num_type = result.get('type', 'Unknown')
            types[num_type] = types.get(num_type, 0) + 1
            
            if result.get('voip_check', {}).get('is_voip'):
                voip_count += 1
        
        print(f"\n    Top Countries:")
        for country, count in sorted(countries.items(), key=lambda x: x[1], reverse=True)[:5]:
            print(f"      • {country}: {count}")
        
        print(f"\n    Top Carriers:")
        for carrier, count in sorted(carriers.items(), key=lambda x: x[1], reverse=True)[:5]:
            print(f"      • {carrier}: {count}")
        
        print(f"\n    Number Types:")
        for num_type, count in types.items():
            print(f"      • {num_type}: {count}")
        
        if voip_count > 0:
            print(f"\n    VoIP/Virtual Numbers: {voip_count}")
        
        print()


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description='PhoneBookLOCA v1.1 - Phone Number Location Lookup Tool',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s +14155552671                      # Single lookup
  %(prog)s +442071838750 -v                  # Verbose mode
  %(prog)s +14155552671 --variants           # Show format variants
  %(prog)s +14155552671 --osint              # Generate OSINT queries
  %(prog)s +14155552671 --reputation         # Check reputation
  %(prog)s -b numbers.txt                    # Batch processing
  %(prog)s -b numbers.txt -o results.csv -f csv  # Batch with CSV export
  %(prog)s --scan document.txt               # Extract numbers from file
  %(prog)s --scan data.txt -o found.txt      # Extract and save
  %(prog)s --config                          # Configure API keys
  %(prog)s                                   # Interactive mode
        """
    )
    
    parser.add_argument('number', nargs='?', help='Phone number to lookup')
    parser.add_argument('-v', '--verbose', action='store_true', help='Show detailed information')
    parser.add_argument('-j', '--json', action='store_true', help='Output in JSON format')
    parser.add_argument('-b', '--batch', metavar='FILE', help='Process numbers from file (one per line)')
    parser.add_argument('-o', '--output', metavar='FILE', help='Save results to file')
    parser.add_argument('-f', '--format', choices=['json', 'csv', 'txt'], default='json',
                       help='Output format (default: json)')
    parser.add_argument('--variants', action='store_true', help='Show common number format variants')
    parser.add_argument('--osint', action='store_true', help='Generate OSINT queries and lookup URLs')
    parser.add_argument('--web-scan', action='store_true', help='Execute concurrent web scan (requires Go scraper)')
    parser.add_argument('--reputation', action='store_true', help='Check number reputation')
    parser.add_argument('--scan', metavar='FILE', help='Scan text file and extract phone numbers')
    parser.add_argument('--quiet', action='store_true', help='Suppress progress output in batch mode')
    parser.add_argument('--config', action='store_true', help='Configure API keys')
    
    args = parser.parse_args()
    
    intel = PhoneIntel()
    
    # Config mode
    if args.config:
        intel.configure_apis()
        return
    
    # Scan mode
    if args.scan:
        intel.scan_text_file(args.scan, args.output)
        return
    
    # Batch mode
    if args.batch:
        intel.batch_lookup(args.batch, args.output, args.format, not args.quiet,
                          osint_mode=args.osint, reputation=args.reputation)
        return
    
    # Single lookup mode
    if args.number:
        intel.print_banner()
        result = intel.lookup_phone_number(args.number, verbose=args.verbose, 
                                          json_output=args.json, show_variants=args.variants,
                                          osint_mode=args.osint, reputation=args.reputation,
                                          web_scan=args.web_scan)
        if args.json and result:
            print(json.dumps(result, indent=2))
        return
    
    # Interactive mode (default)
    intel.interactive_mode(verbose=args.verbose)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\n[*] Exiting...\n")
        sys.exit(0)
